function results = MCMC_dual_calib(settings)
% results = MCMC_dual_calib(settings)
%
% settings is a structure generated by the file MCMC_dual_calib_settings.m.

%% Unpack settings
M                             = settings.M;
burn_in                       = settings.burn_in;
sim_x                         = settings.sim_x;
sim_t1                        = settings.sim_t1;
sim_t2                        = settings.sim_t2;
sim_y                         = settings.sim_y;
obs_x                         = settings.obs_x;
obs_t2                        = settings.obs_t2;
obs_y                         = settings.obs_y;
des_x                         = settings.des_x;
des_y                         = settings.des_y;
min_t1                        = settings.min_t1;
range_t1                      = settings.range_t1;
min_t2                        = settings.min_t2;
range_t2                      = settings.range_t2;
obs_var                       = settings.obs_var;
des_var                       = settings.des_var;
additional_discrep_cov        = settings.additional_discrep_cov;
additional_discrep_mean       = settings.additional_discrep_mean;
emulator_use                  = settings.emulator_use;
obs_var_est                   = settings.obs_var_est;
obs_var_same                  = settings.obs_var_same;
des_var_est                   = settings.des_var_est;
mean_sim                      = settings.mean_sim;
emulator_rho                  = settings.emulator_rho;
emulator_lambda               = settings.emulator_lambda;
mean_obs                      = settings.mean_obs;
obs_rho                       = settings.obs_rho_init;
obs_lambda                    = settings.obs_lambda_init;
des_rho                       = settings.des_rho_init;
des_lambda                    = settings.des_lambda_init;
theta1_proposal               = settings.theta1_proposal;
theta2_proposal               = settings.theta2_proposal;
rho_proposal                  = settings.rho_proposal;
lambda_proposal               = settings.lambda_proposal;
obs_var_proposal              = settings.obs_var_proposal;
des_var_proposal              = settings.des_var_proposal;
theta1_prop_log_mh_correction = settings.theta1_prop_log_mh_correction;
theta2_prop_log_mh_correction = settings.theta2_prop_log_mh_correction;
rho_prop_log_mh_correction    = settings.rho_prop_log_mh_correction;
lambda_prop_log_mh_correction = settings.lambda_prop_log_mh_correction;
obs_var_prop_log_mh_correction= settings.obs_var_prop_log_mh_correction;
des_var_prop_log_mh_correction= settings.des_var_prop_log_mh_correction;
obs_Sigma_rho                 = settings.obs_Sigma_rho;
obs_Sigma_lambda              = settings.obs_Sigma_lambda;
des_Sigma_rho                 = settings.des_Sigma_rho;
des_Sigma_lambda              = settings.des_Sigma_lambda;
obs_var_Sigma                 = settings.obs_var_Sigma;
des_var_Sigma                 = settings.des_var_Sigma;
log_obs_rho_prior_fn          = settings.log_obs_rho_prior;
log_obs_lambda_prior_fn       = settings.log_obs_lambda_prior;
log_des_rho_prior_fn          = settings.log_des_rho_prior;
log_des_lambda_prior_fn       = settings.log_des_lambda_prior;
log_obs_var_prior_fn          = settings.log_obs_var_prior_fn;
log_des_var_prior_fn          = settings.log_des_var_prior_fn;
theta1                        = settings.theta1_init;
theta2                        = settings.theta2_init;
Sigma_theta1                  = settings.theta1_prop_cov;
Sigma_theta2                  = settings.theta2_prop_cov;
log_theta1_prior_fn           = settings.log_theta1_prior;
log_theta2_prior_fn           = settings.log_theta2_prior;
obs_final_size                = settings.obs_final_size;
true_phenomenon               = settings.true_phenomenon;
true_obs_var                  = settings.true_obs_var;
doplot                        = settings.doplot;
obs_discrep                   = settings.obs_discrep;
des_discrep                   = settings.des_discrep;
obs_discrep_use_MLEs          = settings.obs_discrep_use_MLEs;
modular                       = settings.modular;
verbose                       = settings.verbose;

%% Preallocate some arrays for speed
dim_y = size(obs_y,2);
obs_cov_mat = zeros(size(obs_x,1),size(obs_x,1),dim_y);
des_cov_mat = zeros(size(des_x,1),size(des_x,1),dim_y);
obs_rho_s   = obs_rho;
des_rho_s   = des_rho;
obs_lambda_s = obs_lambda;
des_lambda_s = des_lambda;
obs_var_s = obs_var;
des_var_s = des_var;
obs_cov_mat_s = obs_cov_mat;
des_cov_mat_s = des_cov_mat;

%% Set some useful variables
% nugsize tells us what size nugget to add to a matrix for computational
% stability. Here, it's just a constant, but is introduced as a function so
% that it can easily be upgraded to something fancier if desired.
nugsize = @(X) 1e-9;
% D is the vector of all outputs from all sources.
D = [ sim_y ; obs_y ; des_y ] ;
% R is the vector of the simulator outputs and real observations.
R = [ sim_y ; obs_y ] ;
opt_acc_rate = 0.234 ; % Acceptance rate treated as optimal in MCMC
upd = 100 ; % Tune adaptive covariances (and update plots) every upd loops
% % The next four variables will be used when the values being sampled are
% % not univariate, so that the plots cycle through which element of each
% % vector is displayed.
% col_theta1     = 0;
% col_theta2     = 0;
% col_obs_rho    = 0;
% col_obs_lambda = 0;
% col_des_rho    = 0;
% col_des_lambda = 0;
logit = @(a) log(a./(1-a)) ; 
% To do: make different cov mat possible for each model output
for ii = 1:dim_y
    obs_cov_mat(:,:,ii) = eye(size(obs_x,1)) * obs_var(ii);
    des_cov_mat(:,:,ii) = eye(size(des_x,1)) * des_var(ii);
end

mean_sim_vals = mean_sim([sim_x,sim_t1,sim_t2]); 
dim_y_seq = 1:dim_y;

%% Set up for Sequential DoE
% How many total new observations to make
new_obs_size = obs_final_size - size(obs_x,1) ; 
% How many new observations to make every upd iterations in burn-in period
obs_per_upd = ceil(new_obs_size / floor(burn_in / upd) );
x_new_all = lhsdesign(new_obs_size,size(obs_x,2)) ;
x_location_idx = 1 ; % Tells where in x_new_all we currently are


%% Set mean functions for GPs
% Currently, constant mean zero is used for discrepancy  GP. 
% However, it is implemented here in function form so that it can be 
% changed easily in the future if desired.
mean_des = @(a) zeros(size(a,1),dim_y); 


%% Prepare that part of covariance matrix which will not change in MCMC
% The cov matrix we need, Sigma_z, can be decomposed so that this big part
% of it remains unchanged, so that we need calculate that only this once.
% Massive computation savings over getting Sigma_z from scratch each time:
Sigma_emulator_simsim = nan(size(sim_x,1),size(sim_x,1),dim_y);
for ii = 1:dim_y
    Sigma_emulator_simsim(:,:,ii) = ...
        gp_cov(emulator_rho(:,ii),...
        [sim_x sim_t1 sim_t2],[sim_x sim_t1 sim_t2],...
        emulator_lambda(ii),false);
end


%% Initialize some variables for later use
startplot          = 1                             ;
accepted_theta1    = 0                             ; % accepted theta1
accepted_theta2    = 0                             ; % accepted theta2
accepted_des_rho   = zeros(1,dim_y)                ; % accepted des_rho
accepted_des_lambda= zeros(1,dim_y)                ; % accepted des_lambda
accepted_obs_rho   = zeros(1,dim_y)                ; % accepted obs_rho
accepted_obs_lambda= zeros(1,dim_y)                ; % accepted obs_lambda
accepted_obs_var   = zeros(1,dim_y)                ; % accepted obs_var
accepted_des_var   = zeros(1,dim_y)                ; % accepted des_var
msg                = 0                             ; % For console output
theta1_rec         = zeros(M,numel(theta1))        ;
theta2_rec         = zeros(M,numel(theta2))        ;
theta1_rec(1,:)    = theta1                        ;
theta2_rec(1,:)    = theta2                        ;
des_rho_rec        = zeros(M,size(des_rho,1),dim_y);
des_rho_rec(1,:,:) = des_rho                       ;
des_lambda_rec     = zeros(M,dim_y)                ;
des_lambda_rec(1,:)= des_lambda                    ;
obs_rho_rec        = zeros(M,size(obs_rho,1),dim_y);
obs_rho_rec(1,:,:) = obs_rho                       ;
obs_lambda_rec     = zeros(M,dim_y)                ;
obs_lambda_rec(1,:)= obs_lambda                    ;
obs_var_rec        = zeros(M,dim_y)                ;
obs_var_rec(1,:)   = obs_var                       ;
des_var_rec        = zeros(M,dim_y)                ;
des_var_rec(1,:)   = des_var                       ;
mult_theta1        = 10                            ; % mult. for proposal
mult_theta2        = 10                            ; 
mult_obs_rho       = 10 * ones(dim_y,1)            ; 
mult_obs_lambda    = 10 * ones(dim_y,1)            ; 
mult_des_rho       = 10 * ones(dim_y,1)            ; 
mult_des_lambda    = 10 * ones(dim_y,1)            ; 
mult_obs_var       = 10 * ones(dim_y,1)             ;
mult_des_var       = 10 * ones(dim_y,1)            ;


%% Get initial log likelihoods
% First, get the rest of the covariance matrix. We need to get the
% covariance matrices for the emulator of each combination of simulator
% runs, real observations, and desired observations; then we need to get
% the covariance matrices for the true discrepancy for each combination of
% true observations and desired observations; then we need to get the
% covariance matrix for the target discrepancy on the desired observations.
% Then we need to combine all these into one big covariance matrix.
additional_discrep_cov_mat = ...
    additional_discrep_cov(obs_x,theta1) ; % Default 0
% Pre-allocate for speed
Sigma_emulator_simobs = nan(size(sim_x,1),size(obs_x,1),dim_y);
Sigma_emulator_simdes = nan(size(sim_x,1),size(des_x,1),dim_y);
Sigma_emulator_obsobs = nan(size(obs_x,1),size(obs_x,1),dim_y);
Sigma_emulator_obsdes = nan(size(obs_x,1),size(des_x,1),dim_y);
Sigma_emulator_desdes = nan(size(des_x,1),size(des_x,1),dim_y);
Sigma_obs_dscr_obsobs = nan(size(obs_x,1),size(obs_x,1),dim_y);
Sigma_obs_dscr_obsdes = nan(size(obs_x,1),size(des_x,1),dim_y);
Sigma_obs_dscr_desdes = nan(size(des_x,1),size(des_x,1),dim_y);
Sigma_des_dscr_desdes = nan(size(des_x,1),size(des_x,1),dim_y);
Sigma_R = ...
    nan(size(sim_x,1)+size(obs_x,1),size(sim_x,1)+size(obs_x,1),dim_y);
Sigma_D = ...
    nan(size(sim_x,1)+size(obs_x,1)+size(des_x,1),...
        size(sim_x,1)+size(obs_x,1)+size(des_x,1),dim_y);
Sigma_emulator_simobs_s = nan(size(sim_x,1),size(obs_x,1),dim_y);
Sigma_emulator_simdes_s = nan(size(sim_x,1),size(des_x,1),dim_y);
Sigma_emulator_obsobs_s = nan(size(obs_x,1),size(obs_x,1),dim_y);
Sigma_emulator_obsdes_s = nan(size(obs_x,1),size(des_x,1),dim_y);
Sigma_emulator_desdes_s = nan(size(des_x,1),size(des_x,1),dim_y);
Sigma_obs_dscr_obsobs_s = nan(size(obs_x,1),size(obs_x,1),dim_y);
Sigma_obs_dscr_obsdes_s = nan(size(obs_x,1),size(des_x,1),dim_y);
Sigma_obs_dscr_desdes_s = nan(size(des_x,1),size(des_x,1),dim_y);
Sigma_des_dscr_desdes_s = nan(size(des_x,1),size(des_x,1),dim_y);
Sigma_R_s = ...
    nan(size(sim_x,1)+size(obs_x,1),size(sim_x,1)+size(obs_x,1),dim_y);
Sigma_D_s = ...
    nan(size(sim_x,1)+size(obs_x,1)+size(des_x,1),...
        size(sim_x,1)+size(obs_x,1)+size(des_x,1),dim_y);
for ii = 1 : dim_y
    Sigma_emulator_simobs(:,:,ii) = ...
        gp_cov(emulator_rho(:,ii),[sim_x sim_t1 sim_t2],...
            [obs_x repmat(theta1',size(obs_x,1),1) obs_t2],...
            emulator_lambda(ii),false);
    Sigma_emulator_simdes(:,:,ii) = ...
        gp_cov(emulator_rho(:,ii),[sim_x sim_t1 sim_t2],...
            [des_x repmat(theta1',size(des_x,1),1) ...
                repmat(theta2',size(des_x,1),1)],...
            emulator_lambda(ii),false);
    Sigma_emulator_obsobs(:,:,ii) = ...
        gp_cov(emulator_rho(:,ii),...
            [obs_x repmat(theta1',size(obs_x,1),1) obs_t2],...
            [obs_x repmat(theta1',size(obs_x,1),1) obs_t2],...
            emulator_lambda(ii),false);
    Sigma_emulator_obsdes(:,:,ii) = ...
        gp_cov(emulator_rho(:,ii),...
            [obs_x repmat(theta1',size(obs_x,1),1) obs_t2],...
            [des_x repmat(theta1',size(des_x,1),1) ...
                repmat(theta2',size(des_x,1),1)],...
            emulator_lambda(ii),false);
    Sigma_emulator_desdes(:,:,ii) = ...
        gp_cov(emulator_rho(:,ii),...
            [des_x repmat(theta1',size(des_x,1),1) ...
                repmat(theta2',size(des_x,1),1)],...
            [des_x repmat(theta1',size(des_x,1),1) ...
                repmat(theta2',size(des_x,1),1)],...
            emulator_lambda(ii),false);
    Sigma_obs_dscr_obsobs(:,:,ii) = ...
        gp_cov(obs_rho(:,ii),[obs_x obs_t2],[obs_x obs_t2],...
            obs_lambda(ii),false);
    Sigma_obs_dscr_obsdes(:,:,ii) = ...
        gp_cov(obs_rho(:,ii),[obs_x obs_t2],...
            [des_x repmat(theta2',size(des_x,1))],...
            obs_lambda(ii),false);
    Sigma_obs_dscr_desdes(:,:,ii) = ...
        gp_cov(obs_rho(:,ii),[des_x repmat(theta2',size(des_x,1))],...
            [des_x repmat(theta2',size(des_x,1))],...
            obs_lambda(ii),false);
    Sigma_des_dscr_desdes(:,:,ii) = ...
        gp_cov(des_rho(:,ii),des_x,des_x,des_lambda(ii),false);
    % Now to combine everything into two big covariance matrices:
    Sigma_R(:,:,ii) = [... % The covariance of R
        Sigma_emulator_simsim(:,:,ii) Sigma_emulator_simobs(:,:,ii) ; 
        Sigma_emulator_simobs(:,:,ii)' ...
            Sigma_emulator_obsobs(:,:,ii) + ...
            Sigma_obs_dscr_obsobs(:,:,ii) + obs_cov_mat(:,:,ii) + ...
            additional_discrep_cov_mat(:,:,ii)...% By default adcm is zero
        ];
    Sigma_D(:,:,ii) = [... % The covariance of D
        Sigma_R(:,:,ii) ...
            [Sigma_emulator_simdes(:,:,ii); ...
                Sigma_emulator_obsdes(:,:,ii) + ...
                Sigma_obs_dscr_obsdes(:,:,ii)];
        Sigma_emulator_simdes(:,:,ii)' ...
            Sigma_emulator_obsdes(:,:,ii)' + ...
                Sigma_obs_dscr_obsdes(:,:,ii)' ...
            Sigma_emulator_desdes(:,:,ii) + ...
                Sigma_obs_dscr_desdes(:,:,ii) + ...
                Sigma_des_dscr_desdes(:,:,ii) + des_cov_mat(:,:,ii)];
    % Add nugget for computational tractability:
    Sigma_D(:,:,ii) = Sigma_D(:,:,ii) + ...
        eye(size(Sigma_D(:,:,ii))) * nugsize(Sigma_D(:,:,ii)) ;
end

% Now to get the log likelihoods
mu_R = [mean_sim_vals ; ...
    mean_sim([obs_x,repmat(theta1',size(obs_x,1),1),obs_t2]) + ...
        mean_obs(obs_x,obs_t2) + ...
        additional_discrep_mean(theta1)]; %Mean of R. By default adm() is 0
mu_D = [mu_R ; 
    mean_sim([des_x,repmat(theta1',size(des_x,1),1),...
        repmat(theta2',size(des_x,1),1)]) + ...
        mean_obs(des_x,repmat(theta2',size(des_x,1),1)) + ...
        mean_des(des_x)]; % Mean of D
log_cond_dens_D = arrayfun(... % get likelihood of each output
        @(b) logmvnpdfFS(D(:,b)',mu_D(:,b)',Sigma_D(:,:,b)), 1:dim_y);
log_theta1_prior = log_theta1_prior_fn(theta1);
log_theta2_prior = log_theta2_prior_fn(theta2);
if obs_discrep
    log_obs_rho_prior = arrayfun(...
        @(b) log_obs_rho_prior_fn(obs_rho(:,b)), 1:dim_y);
    log_obs_lambda_prior = arrayfun(...
        @(b) log_obs_lambda_prior_fn(obs_lambda(b)), 1:dim_y);
    log_obs_lambda_prior_s = log_obs_lambda_prior; % Preallocate
end
if des_discrep
    log_des_rho_prior = arrayfun(...
        @(b) log_des_rho_prior_fn(des_rho(:,b)), 1:dim_y);
    log_des_lambda_prior = arrayfun(...
        @(b) log_des_lambda_prior_fn(des_lambda(b)),1:dim_y);
    log_des_lambda_prior_s = log_des_lambda_prior; % Preallocate
end
if any(obs_var_est)
%     log_obs_var_prior = arrayfun(...
%         @(b) log_obs_var_prior_fn(obs_var(b)), dim_y_seq(logical(obs_var_est)));
    log_obs_var_prior = log_obs_var_prior_fn(obs_var);
    log_obs_var_prior_s = log_obs_var_prior; % Preallocate
end
if des_var_est
    log_des_var_prior = arrayfun(...
        @(b) log_des_var_prior_fn(des_var(b)), 1:dim_y);
    log_des_var_prior_s = log_des_var_prior; % Preallocate
end


%%%%%%%%%%%%%%%
%% MCMC loop %%
%%%%%%%%%%%%%%%
if doplot
    figure('units','normalized','outerposition',[0 0 1 1]);
    num_ax = numel(theta1) + numel(theta2) + ...
        (numel(obs_rho) + numel(obs_lambda)) * obs_discrep + ...
        (numel(des_rho) + numel(des_lambda)) * des_discrep + ...
        sum(obs_var_est) + ...
        numel(des_var) * des_var_est; % Number of axes needed for plots
    num_ax_cols = ceil(sqrt(num_ax)); % Number of columns
    num_ax_rows = ceil(num_ax/num_ax_cols); % Number of rows
    ax = gobjects(num_ax,1); % Preallocate axes array
    for jj=1:num_ax
        ax(jj) = subplot(num_ax_rows,num_ax_cols,jj);
    end
end
for ii = 2:M
    
    %% Draw new theta1
    if numel(theta1)>0
    
    theta1_s = theta1_proposal(theta1,Sigma_theta1)';
%     zero_mult = zeros(size(Sigma_theta1)); zero_mult(jj,jj)=1;
%     theta1_s = theta1_proposal(theta1,Sigma_theta1 .* zero_mult )';
    
    % Get acceptance ratio alpha
    % To do this, we'll first find the updated log factors of the
    % likelihood using the new draw theta1_s, using the updated mean and
    % covariance of the GPs. Only certain parts of the big covariance
    % matrix Sigma need to be updated -- those that depend on theta1.
    % We get mu_R and Sigma_R, and mu_D and Sigma_D. mu_R and Sigma_R are
    % restricted to the non-fake data -- the simulation runs and the real
    % observations. These are used for the modularized approach. Whether or
    % not the modularized approach is used, we also need mu_D and Sigma_D,
    % which are unrestricted in that they include all data, even the fake
    % observations. 
    mu_R_s = [mean_sim_vals ; ...
        mean_sim([obs_x,repmat(theta1_s',size(obs_x,1),1),obs_t2]) + ...
            mean_obs(obs_x,obs_t2) + ...
            additional_discrep_mean(theta1_s)]; % By default adm() is 0
    mu_D_s = [mu_R_s;
        mean_sim([des_x,repmat(theta1_s',size(des_x,1),1),...
            repmat(theta2',size(des_x,1),1)]) + ...
            mean_obs(des_x,repmat(theta2',size(des_x,1),1)) + ...
            mean_des(des_x)]; % Mean of D
    additional_discrep_cov_mat_s = additional_discrep_cov(obs_x,theta1_s) ;
    for jj = 1 : dim_y % For each model output
        Sigma_emulator_simobs_s(:,:,jj) = gp_cov(emulator_rho(:,jj),...
            [sim_x sim_t1 sim_t2],...
            [obs_x repmat(theta1_s',size(obs_x,1),1) obs_t2],...
            emulator_lambda(jj),...
            false);
        Sigma_emulator_simdes_s(:,:,jj) = gp_cov(emulator_rho(:,jj),...
            [sim_x sim_t1 sim_t2],...
            [des_x repmat(theta1_s',size(des_x,1),1) ...
                repmat(theta2',size(des_x,1),1)],...
            emulator_lambda(jj),false);
        Sigma_emulator_obsobs_s(:,:,jj) = gp_cov(emulator_rho(:,jj),...
            [obs_x repmat(theta1_s',size(obs_x,1),1) obs_t2],...
            [obs_x repmat(theta1_s',size(obs_x,1),1) obs_t2],...
            emulator_lambda(jj),false);
        Sigma_emulator_obsdes_s(:,:,jj) = gp_cov(emulator_rho(:,jj),...
            [obs_x repmat(theta1_s',size(obs_x,1),1) obs_t2],...
            [des_x repmat(theta1_s',size(des_x,1),1) ...
                repmat(theta2',size(des_x,1),1)],...
            emulator_lambda(jj),false);
        Sigma_emulator_desdes_s(:,:,jj) = gp_cov(emulator_rho(:,jj),...
            [des_x repmat(theta1_s',size(des_x,1),1) ...
                repmat(theta2',size(des_x,1),1)],...
            [des_x repmat(theta1_s',size(des_x,1),1) ...
                repmat(theta2',size(des_x,1),1)],...
            emulator_lambda(jj),false);
        Sigma_R_s(:,:,jj) = [...
            Sigma_emulator_simsim(:,:,jj) Sigma_emulator_simobs_s(:,:,jj) ;
            Sigma_emulator_simobs_s(:,:,jj)' ...
                Sigma_emulator_obsobs_s(:,:,jj) + ...
                    Sigma_obs_dscr_obsobs(:,:,jj) + ...
                    obs_cov_mat(:,:,jj) + ...
                    additional_discrep_cov_mat_s(:,:,jj)
        ];
        Sigma_D_s(:,:,jj) = [...
            Sigma_R_s(:,:,jj) [Sigma_emulator_simdes_s(:,:,jj) ; ...
                Sigma_emulator_obsdes_s(:,:,jj) + ...
                Sigma_obs_dscr_obsdes(:,:,jj)];
            Sigma_emulator_simdes_s(:,:,jj)' ...
                Sigma_emulator_obsdes_s(:,:,jj)' + ...
                    Sigma_obs_dscr_obsdes(:,:,jj)' ...
                Sigma_emulator_desdes_s(:,:,jj) + ...
                    Sigma_obs_dscr_desdes(:,:,jj) + ...
                    Sigma_des_dscr_desdes(:,:,jj) + des_cov_mat(:,:,jj)...
        ];
        % Add nugget for computational tractability
        Sigma_D_s(:,:,jj) = Sigma_D_s(:,:,jj) + ...
            eye(size(Sigma_D_s(:,:,jj))) * nugsize(Sigma_D_s(:,:,jj)) ;
        Sigma_R_s(:,:,jj) = Sigma_R_s(:,:,jj) + ...
            eye(size(Sigma_R_s(:,:,jj))) * nugsize(Sigma_R_s(:,:,jj)) ;
    end
    % Now we can get the log factors of the likelihood for the new draw,
    % using both R and D
    log_cond_dens_D_s = arrayfun(... % get likelihood of each output
            @(b)logmvnpdfFS(D(:,b)',mu_D_s(:,b)',Sigma_D_s(:,:,b)), 1:dim_y);
    log_theta1_prior_s = log_theta1_prior_fn(theta1_s);
    if modular
        log_cond_dens_R_s = arrayfun(... % get likelihood of each output
                @(b) logmvnpdfFS(...
                    R(:,b)',mu_R_s(:,b)',Sigma_R_s(:,:,b)), 1:dim_y);
        log_lik_theta1_s = sum(log_cond_dens_R_s) + log_theta1_prior_s; 
        % We also need to get the likelihood for the old draw, since under
        % a modular approach it is not updated in the other draws
        Sigma_R = [...
            Sigma_emulator_simsim Sigma_emulator_simobs ;
            Sigma_emulator_simobs' ...
                Sigma_emulator_obsobs + Sigma_obs_dscr_obsobs + ...
                    obs_cov_mat(:,:,jj) + ...
                    additional_discrep_cov(obs_x,theta1)
        ];
        Sigma_R = Sigma_R + ...
            repmat(eye(size(Sigma_R)),1,1,dim_y) * nugsize(Sigma_R) ;
        log_cond_dens_R = arrayfun(... % get likelihood of each output
                @(b)logmvnpdfFS(R(:,b)',mu_R(:,b)',Sigma_R(:,:,b)), 1:dim_y);
        log_lik_theta1 = sum(log_cond_dens_R) + log_theta1_prior;
    else
        log_lik_theta1_s = sum(log_cond_dens_D_s) + log_theta1_prior_s; 
        log_lik_theta1 = sum(log_cond_dens_D) + log_theta1_prior;
    end

    % Now we can get the acceptance ratio
    log_alpha = log_lik_theta1_s - log_lik_theta1 + ...
        theta1_prop_log_mh_correction(theta1_s,theta1);
    
    % Now accept theta1_s with probability min(alpha,1)
    if log(rand) < log_alpha
        theta1 = theta1_s;
        mu_R = mu_R_s;
        mu_D = mu_D_s;
        Sigma_emulator_simobs = Sigma_emulator_simobs_s;
        Sigma_emulator_simdes = Sigma_emulator_simdes_s;
        Sigma_emulator_obsobs = Sigma_emulator_obsobs_s;
        Sigma_emulator_obsdes = Sigma_emulator_obsdes_s;
        Sigma_emulator_desdes = Sigma_emulator_desdes_s;
        log_cond_dens_D = log_cond_dens_D_s;
        log_theta1_prior = log_theta1_prior_s;
        additional_discrep_cov_mat = additional_discrep_cov_mat_s ;
        accepted_theta1 = accepted_theta1 + 1;
    end
    
    end % End of section: Draw new theta1
    
    %% Draw new theta2
    if numel(theta2)>0
    theta2_s = theta2_proposal(theta2,Sigma_theta2);
%         save temp
    
    % Get acceptance ratio alpha
    % To do this, we'll first find the updated log factors of the
    % likelihood using the new draw theta2_s, using the updated mean and
    % covariance of the GPs. Only certain parts of the big covariance
    % matrix Sigma need to be updated -- those that depend on theta2.
    mu_D_s = [mu_R;
        mean_sim([des_x,repmat(theta1',size(des_x,1),1),...
            repmat(theta2_s',size(des_x,1),1)]) + ...
            mean_obs(des_x,repmat(theta2_s',size(des_x,1),1)) + ...
            mean_des(des_x)]; % Mean of D
    for jj = 1:dim_y % For each model output
        Sigma_emulator_simdes_s(:,:,jj) = gp_cov(emulator_rho(:,jj),...
            [sim_x sim_t1 sim_t2],...
            [des_x repmat(theta1',size(des_x,1),1) ...
                repmat(theta2_s',size(des_x,1),1)],...
            emulator_lambda(jj),false);
        Sigma_emulator_obsdes_s(:,:,jj) = gp_cov(emulator_rho(:,jj),...
            [obs_x repmat(theta1',size(obs_x,1),1) obs_t2],...
            [des_x repmat(theta1',size(des_x,1),1) ...
                repmat(theta2_s',size(des_x,1),1)],...
            emulator_lambda(jj),false);
        Sigma_emulator_desdes_s(:,:,jj) = gp_cov(emulator_rho(:,jj),...
            [des_x repmat(theta1',size(des_x,1),1) ...
                repmat(theta2_s',size(des_x,1),1)],...
            [des_x repmat(theta1',size(des_x,1),1) ...
                repmat(theta2_s',size(des_x,1),1)],...
            emulator_lambda(jj),false);
        Sigma_obs_dscr_obsdes_s(:,:,jj) = gp_cov(obs_rho(:,jj),...
            [obs_x obs_t2],[des_x repmat(theta2_s',size(des_x,1),1)],...
            obs_lambda(jj),false);
        Sigma_obs_dscr_desdes_s(:,:,jj) = gp_cov(obs_rho(:,jj),...
            [des_x repmat(theta2_s',size(des_x,1),1)],...
            [des_x repmat(theta2_s',size(des_x,1),1)],...
            obs_lambda(jj),false);
        % Put new Sigma_D together
        Sigma_D_s(:,:,jj) = [...
            Sigma_emulator_simsim(:,:,jj) Sigma_emulator_simobs(:,:,jj) ...
                Sigma_emulator_simdes_s(:,:,jj) ;
            Sigma_emulator_simobs(:,:,jj)' ...
                Sigma_emulator_obsobs(:,:,jj) + ...
                    Sigma_obs_dscr_obsobs(:,:,jj) + ...
                    obs_cov_mat(:,:,jj) + ...
                    additional_discrep_cov_mat(:,:,jj) ...
                Sigma_emulator_obsdes_s(:,:,jj) + ...
                    Sigma_obs_dscr_obsdes_s(:,:,jj);
            Sigma_emulator_simdes_s(:,:,jj)' ...
                Sigma_emulator_obsdes_s(:,:,jj)' + ...
                    Sigma_obs_dscr_obsdes_s(:,:,jj)' ...
                Sigma_emulator_desdes_s(:,:,jj) + ...
                    Sigma_obs_dscr_desdes_s(:,:,jj) + ...
                    Sigma_des_dscr_desdes(:,:,jj) + des_cov_mat(:,:,jj)...
        ];
        % Add nugget for computational tractability
        Sigma_D_s(:,:,jj) = Sigma_D_s(:,:,jj) + ...
            eye(size(Sigma_D_s(:,:,jj))) * nugsize(Sigma_D_s(:,:,jj)) ;
    end
    % Now we can get the log factors of the likelihood for the new draw
    log_cond_dens_D_s = arrayfun(... % get likelihood of each output
            @(b)logmvnpdfFS(D(:,b)',mu_D_s(:,b)',Sigma_D_s(:,:,b)), 1:dim_y);
    log_theta2_prior_s = log_theta2_prior_fn(theta2_s);

    log_lik_theta2_s = sum(log_cond_dens_D_s) + log_theta2_prior_s; 
    % And we get the likelihood for the old draw
    log_lik_theta2 = sum(log_cond_dens_D) + log_theta2_prior;


    % Now we can get the acceptance ratio
    log_alpha = log_lik_theta2_s - log_lik_theta2 + ...
        theta2_prop_log_mh_correction(theta2_s,theta2);
%     theta2_s
%     exp(log_alpha)
    
    % Now accept theta2_s with probability min(alpha,1)
    if log(rand) < log_alpha
        theta2 = theta2_s;
        mu_D = mu_D_s;
        Sigma_emulator_simdes = Sigma_emulator_simdes_s;
        Sigma_emulator_obsdes = Sigma_emulator_obsdes_s;
        Sigma_emulator_desdes = Sigma_emulator_desdes_s;
        Sigma_obs_dscr_obsdes = Sigma_obs_dscr_obsdes_s;
        Sigma_obs_dscr_desdes = Sigma_obs_dscr_desdes_s;
        log_theta2_prior = log_theta2_prior_s;
        log_cond_dens_D = log_cond_dens_D_s;
        accepted_theta2 = accepted_theta2 + 1;
    end
%     theta2
% t2s = [t2s ; theta2];
    end
    
    %% Draw new obs_rho (if discrepancy used)
    if obs_discrep && (~obs_discrep_use_MLEs || ii<=upd)
    for jj = 1 : dim_y % For each model output
        obs_rho_s(:,jj) = ...
            rho_proposal(obs_rho(:,jj),obs_Sigma_rho(:,:,jj));

        % Get acceptance ratio alpha
        % To do this, we'll first find the updated log factors of the
        % likelihood using the new draw obs_rho_s, using updated covariance
        % of the GPs. Only part of the big covariance
        % matrix Sigma need to be updated -- the part depends on obs_rho.
        % We get Sigma_R and Sigma_D. Sigma_R is
        % restricted to the non-fake data - the simulation runs & the real
        % observations. This is used for the modulrzd approach. Whether or
        % not the modularized approach is used, we also need Sigma_D,
        % which is unrestricted in that it includes all data, even the fake
        % observations. 
        Sigma_obs_dscr_obsobs_s(:,:,jj) = ...
            gp_cov(obs_rho_s(:,jj),[obs_x obs_t2],[obs_x obs_t2],...
                obs_lambda(jj),false);
        Sigma_obs_dscr_obsdes_s(:,:,jj) = ...
            gp_cov(obs_rho_s(:,jj),[obs_x obs_t2],...
                [des_x repmat(theta2',size(des_x,1))],...
                obs_lambda(jj),false);
        Sigma_obs_dscr_desdes_s(:,:,jj) = ...
            gp_cov(obs_rho_s(:,jj),...
                [des_x repmat(theta2',size(des_x,1))],...
                [des_x repmat(theta2',size(des_x,1))],...
                obs_lambda(jj),false);
        Sigma_R_s(:,:,jj) = [...
            Sigma_emulator_simsim(:,:,jj) Sigma_emulator_simobs(:,:,jj) ;
            Sigma_emulator_simobs(:,:,jj)' ...
                Sigma_emulator_obsobs(:,:,jj) + ...
                    Sigma_obs_dscr_obsobs_s(:,:,jj) + ...
                    obs_cov_mat(:,:,jj) + ...
                    additional_discrep_cov_mat(:,:,jj)
        ];
        Sigma_D_s(:,:,jj) = [...
            Sigma_R_s(:,:,jj) [Sigma_emulator_simdes(:,:,jj) ; ...
                Sigma_emulator_obsdes(:,:,jj) + ...
                    Sigma_obs_dscr_obsdes_s(:,:,jj)];
            Sigma_emulator_simdes(:,:,jj)' ...
                Sigma_emulator_obsdes(:,:,jj)' + ...
                    Sigma_obs_dscr_obsdes_s(:,:,jj)' ...
                Sigma_emulator_desdes(:,:,jj) + ...
                    Sigma_obs_dscr_desdes_s(:,:,jj) + ...
                    Sigma_des_dscr_desdes(:,:,jj) + des_cov_mat(:,:,jj)...
        ];
        % Add nugget for computational tractability
        Sigma_R_s(:,:,jj) = Sigma_R_s(:,:,jj) + ...
            eye(size(Sigma_R_s(:,:,jj))) * nugsize(Sigma_R_s(:,:,jj)) ;
        Sigma_D_s(:,:,jj) = Sigma_D_s(:,:,jj) + ...
            eye(size(Sigma_D_s(:,:,jj))) * nugsize(Sigma_D_s(:,:,jj)) ;
        % Now we can get the log factors of the likelihood for the new draw
        log_cond_dens_R_s = ...
            logmvnpdfFS(R(:,jj)',mu_R(:,jj)',Sigma_R_s(:,:,jj));
        log_obs_rho_prior_s = ...
            log_obs_rho_prior_fn(obs_rho_s(:,jj));

        % Get the log likelihood for new & old draw either modulrized or no
        if modular
            log_lik_obs_rho_s = log_cond_dens_R_s + log_obs_rho_prior_s; 
            % We also need to get the likelihood for the old draw, as under
            % a modular approach it is not updated in the other draws
            Sigma_R(:,:,jj) = [...
                Sigma_emulator_simsim(:,:,jj) ...
                    Sigma_emulator_simobs(:,:,jj);
                Sigma_emulator_simobs(:,:,jj)' ...
                    Sigma_emulator_obsobs(:,:,jj) + ...
                        Sigma_obs_dscr_obsobs(:,:,jj) + ...
                        obs_cov_mat(:,:,jj) + ...
                        additional_discrep_cov_mat(:,:,jj)
                ];
            Sigma_R(:,:,jj) = Sigma_R(:,:,jj) + ...
                eye(size(Sigma_R(:,:,jj))) * nugsize(Sigma_R(:,:,jj)) ;
            log_cond_dens_R = ...
                logmvnpdfFS(R(:,jj)',mu_R(:,jj)',Sigma_R(:,:,jj));
            log_lik_obs_rho = log_cond_dens_R + log_obs_rho_prior(jj);
        else
            log_cond_dens_D_s(jj) = ...
                logmvnpdfFS(D(:,jj)',mu_D(:,jj)',Sigma_D_s(:,:,jj));
            log_lik_obs_rho_s = log_cond_dens_D_s(jj) + ...
                log_obs_rho_prior_s; 
            log_lik_obs_rho = log_cond_dens_D(jj) + log_obs_rho_prior(jj);
        end
        % Now we can get the acceptance ratio
        log_alpha = log_lik_obs_rho_s - log_lik_obs_rho + ...
            rho_prop_log_mh_correction(obs_rho_s(:,jj),obs_rho(:,jj));

        % Now accept obs_rho_s with probability min(alpha,1)
        if log(rand) < log_alpha
            obs_rho(:,jj) = obs_rho_s(:,jj);
            Sigma_obs_dscr_obsobs(:,:,jj) =Sigma_obs_dscr_obsobs_s(:,:,jj);
            Sigma_obs_dscr_obsdes(:,:,jj) =Sigma_obs_dscr_obsdes_s(:,:,jj);
            Sigma_obs_dscr_desdes(:,:,jj) =Sigma_obs_dscr_desdes_s(:,:,jj);
            log_obs_rho_prior(jj) = log_obs_rho_prior_s;
            if modular % Need to compute new log_cond_dens_D
                log_cond_dens_D_s(jj) = ...
                    logmvnpdfFS(D(:,jj)',mu_D(:,jj)',Sigma_D_s(:,:,jj));
            end
            log_cond_dens_D(jj) = log_cond_dens_D_s(jj);
            accepted_obs_rho(jj) = accepted_obs_rho(jj) + 1;
        end
    end
    end
    
    %% Draw new obs_lambda (if discrepancy used)
    if obs_discrep && (~obs_discrep_use_MLEs || ii<=upd)
    for jj = 1 : dim_y % For each model output
        obs_lambda_s(jj) = ...
            lambda_proposal(obs_lambda(jj),obs_Sigma_lambda(jj));

        % Get acceptance ratio alpha
        % To do this, we'll first find the updated log factors of the
        % likelihood using the new draw lambda_s, using updated covariance 
        % of the GPs. Only part of the big covariance matrix Sigma need be 
        % updated -- the part that depends on obs_lambda.
        Sigma_obs_dscr_obsobs_s(:,:,jj) = ...
            gp_cov(obs_rho(:,jj),[obs_x obs_t2],[obs_x obs_t2],...
                obs_lambda_s(jj),false);
        Sigma_obs_dscr_obsdes_s(:,:,jj) = ...
            gp_cov(obs_rho(:,jj),[obs_x obs_t2],...
                [des_x repmat(theta2',size(des_x,1))],...
                obs_lambda_s(jj),false);
        Sigma_obs_dscr_desdes_s(:,:,jj) = ...
            gp_cov(obs_rho(:,jj),[des_x repmat(theta2',size(des_x,1))],...
                [des_x repmat(theta2',size(des_x,1))],...
                obs_lambda_s(jj),false);
        Sigma_R_s(:,:,jj) = [...
            Sigma_emulator_simsim(:,:,jj) Sigma_emulator_simobs(:,:,jj) ;
            Sigma_emulator_simobs(:,:,jj)' ...
                Sigma_emulator_obsobs(:,:,jj) + ...
                    Sigma_obs_dscr_obsobs_s(:,:,jj) + ...
                    obs_cov_mat(:,:,jj) + ...
                    additional_discrep_cov_mat(:,:,jj)
        ];
        Sigma_D_s(:,:,jj) = [...
            Sigma_R_s(:,:,jj) [Sigma_emulator_simdes(:,:,jj) ; ...
                Sigma_emulator_obsdes(:,:,jj) + ...
                    Sigma_obs_dscr_obsdes_s(:,:,jj)];
            Sigma_emulator_simdes(:,:,jj)' ...
                Sigma_emulator_obsdes(:,:,jj)' + ...
                    Sigma_obs_dscr_obsdes_s(:,:,jj)' ...
                Sigma_emulator_desdes(:,:,jj) + ...
                    Sigma_obs_dscr_desdes_s(:,:,jj) + ...
                    Sigma_des_dscr_desdes(:,:,jj) + des_cov_mat(:,:,jj)...
        ];
        % Add nugget for computational tractability
        Sigma_R_s(:,:,jj) = Sigma_R_s(:,:,jj) + ...
            eye(size(Sigma_R_s(:,:,jj))) * nugsize(Sigma_R_s(:,:,jj)) ;
        Sigma_D_s(:,:,jj) = Sigma_D_s(:,:,jj) + ...
            eye(size(Sigma_D_s(:,:,jj))) * nugsize(Sigma_D_s(:,:,jj)) ;
        % Now we can get the log factors of the likelihood for the new draw
        log_cond_dens_R_s = ...
            logmvnpdfFS(R(:,jj)',mu_R(:,jj)',Sigma_R_s(:,:,jj));
        log_obs_lambda_prior_s(jj) = ...
            log_obs_lambda_prior_fn(obs_lambda_s(jj));
        
        % Get the log likelihoods for new & old draw either modlrized or no
        if modular
            log_lik_obs_lambda_s = log_cond_dens_R_s + ...
                log_obs_lambda_prior_s(jj); 
            % We also need to get the likelihood for the old draw, as under
            % a modular approach it is not updated in the other draws
            Sigma_R(:,:,jj) = [...
                Sigma_emulator_simsim(:,:,jj) ...
                    Sigma_emulator_simobs(:,:,jj);
                Sigma_emulator_simobs(:,:,jj)' ...
                    Sigma_emulator_obsobs(:,:,jj) + ...
                        Sigma_obs_dscr_obsobs(:,:,jj) + ...
                        obs_cov_mat(:,:,jj) + ...
                        additional_discrep_cov_mat(:,:,jj)
            ];
            Sigma_R(:,:,jj) = Sigma_R(:,:,jj) + ...
                eye(size(Sigma_R(:,:,jj))) * nugsize(Sigma_R(:,:,jj)) ;
            log_cond_dens_R = ...
                logmvnpdfFS(R(:,jj)',mu_R(:,jj)',Sigma_R(:,:,jj));
            log_lik_obs_lambda = log_cond_dens_R +log_obs_lambda_prior(jj);
        else
            log_cond_dens_D_s(jj) = ...
                logmvnpdfFS(D(:,jj)',mu_D(:,jj)',Sigma_D_s(:,:,jj));
            log_lik_obs_lambda_s = ...
                log_cond_dens_D_s(jj) + log_obs_lambda_prior_s(jj); 
            log_lik_obs_lambda = ...
                log_cond_dens_D(jj) + log_obs_lambda_prior(jj);
        end
        % Now we can get the acceptance ratio
        log_alpha = log_lik_obs_lambda_s - log_lik_obs_lambda + ...
            lambda_prop_log_mh_correction(obs_lambda_s(jj),obs_lambda(jj));

        % Now accept obs_lambda_s with probability min(alpha,1)
        if log(rand) < log_alpha
            obs_lambda(jj) = obs_lambda_s(jj);
            Sigma_obs_dscr_obsobs(:,:,jj) =Sigma_obs_dscr_obsobs_s(:,:,jj);
            Sigma_obs_dscr_obsdes(:,:,jj) =Sigma_obs_dscr_obsdes_s(:,:,jj);
            Sigma_obs_dscr_desdes(:,:,jj) =Sigma_obs_dscr_desdes_s(:,:,jj);
            log_obs_lambda_prior(jj) = log_obs_lambda_prior_s(jj);
            if modular % Need to compute new log_cond_dens_D
                log_cond_dens_D_s(jj) = ...
                    logmvnpdfFS(D(:,jj)',mu_D(:,jj)',Sigma_D_s(:,:,jj));
            end
            log_cond_dens_D(jj) = log_cond_dens_D_s(jj);
            accepted_obs_lambda(jj) = accepted_obs_lambda(jj) + 1;
        end
    end
    end
    
    %% Draw new des_rho
    if des_discrep % Only draw target outcome discrepancy if des_discrep T
    for jj = 1 : dim_y % For each model output
        des_rho_s(:,jj) =rho_proposal(des_rho(:,jj),des_Sigma_rho(:,:,jj));

        % Get acceptance ratio alpha
        % To do this, we'll first find the updated log factors of the
        % likelihood using the new draw des_rho_s, using updated covariance
        % of the GPs. Only part of the big covariance
        % matrix Sigma need be updated -- the part depending on des_rho.
        Sigma_des_dscr_desdes_s(:,:,jj) = ...
            gp_cov(des_rho_s(:,jj),des_x,des_x,des_lambda(jj),false);

        Sigma_D_s(:,:,jj) = [...
            Sigma_emulator_simsim(:,:,jj) ...
                Sigma_emulator_simobs(:,:,jj) ...
                Sigma_emulator_simdes(:,:,jj) ;
            Sigma_emulator_simobs(:,:,jj)' ...
                Sigma_emulator_obsobs(:,:,jj) + ...
                    Sigma_obs_dscr_obsobs(:,:,jj) + ...
                    obs_cov_mat(:,:,jj) + ...
                    additional_discrep_cov_mat(:,:,jj)...
                Sigma_emulator_obsdes(:,:,jj) + ...
                    Sigma_obs_dscr_obsdes(:,:,jj);
            Sigma_emulator_simdes(:,:,jj)' ...
                Sigma_emulator_obsdes(:,:,jj)' + ...
                    Sigma_obs_dscr_obsdes(:,:,jj)' ...
                Sigma_emulator_desdes(:,:,jj) + ...
                    Sigma_obs_dscr_desdes(:,:,jj) + ...
                    Sigma_des_dscr_desdes_s(:,:,jj) + des_cov_mat(:,:,jj)...
        ];
        % Add nugget for computational tractability
        Sigma_D_s(:,:,jj) = Sigma_D_s(:,:,jj) + ...
            eye(size(Sigma_D_s(:,:,jj))) * nugsize(Sigma_D_s(:,:,jj)) ;
        % Now we can get the log factors of the likelihood for the new draw
        log_cond_dens_D_s(jj) = ...
            logmvnpdfFS(D(:,jj)',mu_D(:,jj)',Sigma_D_s(:,:,jj));
        log_des_rho_prior_s = log_des_rho_prior_fn(des_rho_s(:,jj));
        log_lik_des_rho_s = log_cond_dens_D_s(jj) + log_des_rho_prior_s; 
        % And we get the likelihood for the old draw
        log_lik_des_rho = log_cond_dens_D(jj) + log_des_rho_prior(jj);

        % Now we can get the acceptance ratio
        log_alpha = log_lik_des_rho_s - log_lik_des_rho + ...
            rho_prop_log_mh_correction(des_rho_s(:,jj),des_rho(:,jj));

        % Now accept theta1_s with probability min(alpha,1)
        if log(rand) < log_alpha
            des_rho(:,jj) = des_rho_s(:,jj);
            Sigma_des_dscr_desdes(:,:,jj) =Sigma_des_dscr_desdes_s(:,:,jj);
            log_cond_dens_D(jj) = log_cond_dens_D_s(jj); 
            log_des_rho_prior(jj) = log_des_rho_prior_s(jj);
            accepted_des_rho(jj) = accepted_des_rho(jj) + 1;
        end
    end
    end
    
    %% Draw new des_lambda
    if des_discrep % Only draw target outcome discrepancy if des_discrep T
    for jj = 1 : dim_y % For each model output
        des_lambda_s(jj) = ...
                lambda_proposal(des_lambda(jj),des_Sigma_lambda(jj));

        % Get acceptance ratio alpha
        % To do this, we'll first find the updated log factors of the
        % likelihood using the new draw lambda_s, using the updated cov. 
        % of the GPs. Only part of the big covariance
        % matrix Sigma need to be updated - the part that depends on lambda
        Sigma_des_dscr_desdes_s(:,:,jj) = ...
            gp_cov(des_rho(:,jj),des_x,des_x,des_lambda_s(jj),false);

        Sigma_D_s(:,:,jj) = [...
        Sigma_emulator_simsim(:,:,jj) ...
            Sigma_emulator_simobs(:,:,jj) ...
            Sigma_emulator_simdes(:,:,jj) ;
        Sigma_emulator_simobs(:,:,jj)' ...
            Sigma_emulator_obsobs(:,:,jj) + ...
                Sigma_obs_dscr_obsobs(:,:,jj) + ...
                obs_cov_mat(:,:,jj) + ...
                additional_discrep_cov_mat(:,:,jj)...
            Sigma_emulator_obsdes(:,:,jj) + Sigma_obs_dscr_obsdes(:,:,jj);
        Sigma_emulator_simdes(:,:,jj)' ...
            Sigma_emulator_obsdes(:,:,jj)' + ...
                Sigma_obs_dscr_obsdes(:,:,jj)' ...
            Sigma_emulator_desdes(:,:,jj) + ...
                Sigma_obs_dscr_desdes(:,:,jj) + ...
                Sigma_des_dscr_desdes_s(:,:,jj) + des_cov_mat(:,:,jj)...
        ];
        % Add nugget for computational tractability
        Sigma_D_s(:,:,jj) = Sigma_D_s(:,:,jj) + ...
            eye(size(Sigma_D_s(:,:,jj))) * nugsize(Sigma_D_s(:,:,jj)) ;
        
        % Now we can get the log factors of the likelihood for the new draw
        log_cond_dens_D_s(jj) = ...
            logmvnpdfFS(D(:,jj)',mu_D(:,jj)',Sigma_D_s(:,:,jj));
        log_des_lambda_prior_s(jj) = ...
            log_des_lambda_prior_fn(des_lambda_s(jj));
        log_lik_des_lambda_s = log_cond_dens_D_s(jj) + ...
            log_des_lambda_prior_s(jj); 
        
        % And we get the likelihood for the old draw
        log_lik_des_lambda = log_cond_dens_D(jj) +log_des_lambda_prior(jj);

        % Now we can get the acceptance ratio
        log_alpha = log_lik_des_lambda_s - log_lik_des_lambda + ...
            lambda_prop_log_mh_correction(des_lambda_s(jj),des_lambda(jj));

        % Now accept theta1_s with probability min(alpha,1)
        if log(rand) < log_alpha
            des_lambda(jj) = des_lambda_s(jj);
            Sigma_des_dscr_desdes(:,:,jj) =Sigma_des_dscr_desdes_s(:,:,jj);
            log_des_lambda_prior(jj) = log_des_lambda_prior_s(jj);
            log_cond_dens_D(jj) = log_cond_dens_D_s(jj); 
            accepted_des_lambda(jj) = accepted_des_lambda(jj) + 1;
        end
    end
    end
    
    %% Draw new obs_var
    % If obs_vars are constrained to be the same, draw it here
    if obs_var_same == 1
        obs_var_s(1) = Inf ; 
        while obs_var_s(1) == Inf
            obs_var_s(1) = ...
                obs_var_proposal(obs_var(1),obs_var_Sigma(1)) ;
        end
        obs_var_s = ones(size(obs_var_s))*obs_var_s(1) ;
    end
        
    for jj = 1 : dim_y % For each model output
    if obs_var_est(jj) && size(obs_x,1)>0
        
        % Have to get a non-Inf value here
        if obs_var_same == 0 % If obs_vars not constrained to be same
            obs_var_s(jj) = Inf ; 
            while obs_var_s(jj) == Inf
                obs_var_s(jj) = ...
                    obs_var_proposal(obs_var(jj),obs_var_Sigma(jj)) ;
            end
        end
        
        % Get acceptance ratio alpha
        % To do this, we'll first find the updated log factors of the
        % likelihood using the new draw obs_var_s, using the updated cov. 
        % of the GPs. Only part of the big covariance
        % matrix Sigma need to be updated - obs_cov_mat.
        obs_cov_mat_s(:,:,jj) = eye(size(obs_x,1)) * obs_var_s(jj) ;

        Sigma_D_s(:,:,jj) = [...
            Sigma_emulator_simsim(:,:,jj) ...
                Sigma_emulator_simobs(:,:,jj) ...
                Sigma_emulator_simdes(:,:,jj) ;
            Sigma_emulator_simobs(:,:,jj)' ...
                Sigma_emulator_obsobs(:,:,jj) + ...
                    Sigma_obs_dscr_obsobs(:,:,jj) + ...
                    obs_cov_mat_s(:,:,jj) + ...
                    additional_discrep_cov_mat(:,:,jj)...
                Sigma_emulator_obsdes(:,:,jj) + ...
                Sigma_obs_dscr_obsdes(:,:,jj);
            Sigma_emulator_simdes(:,:,jj)' ...
                Sigma_emulator_obsdes(:,:,jj)' + ...
                    Sigma_obs_dscr_obsdes(:,:,jj)' ...
                Sigma_emulator_desdes(:,:,jj) + ...
                    Sigma_obs_dscr_desdes(:,:,jj) + ...
                    Sigma_des_dscr_desdes(:,:,jj) + des_cov_mat(:,:,jj)...
        ];
        % Add nugget for computational tractability
        Sigma_D_s(:,:,jj) = Sigma_D_s(:,:,jj) + ...
            eye(size(Sigma_D_s(:,:,jj))) * nugsize(Sigma_D_s(:,:,jj)) ;
        
        % We also need the current Sigma_D, for comparison.
        Sigma_D(:,:,jj) = [...
            Sigma_emulator_simsim(:,:,jj) ...
                Sigma_emulator_simobs(:,:,jj) ...
                Sigma_emulator_simdes(:,:,jj) ;
            Sigma_emulator_simobs(:,:,jj)' ...
                Sigma_emulator_obsobs(:,:,jj) + ...
                    Sigma_obs_dscr_obsobs(:,:,jj) + ...
                    obs_cov_mat(:,:,jj) + ...
                    additional_discrep_cov_mat(:,:,jj)...
                Sigma_emulator_obsdes(:,:,jj) + ...
                Sigma_obs_dscr_obsdes(:,:,jj);
            Sigma_emulator_simdes(:,:,jj)' ...
                Sigma_emulator_obsdes(:,:,jj)' + ...
                    Sigma_obs_dscr_obsdes(:,:,jj)' ...
                Sigma_emulator_desdes(:,:,jj) + ...
                    Sigma_obs_dscr_desdes(:,:,jj) + ...
                    Sigma_des_dscr_desdes(:,:,jj) + des_cov_mat(:,:,jj)...
        ];
        % Add nugget for computational tractability
        Sigma_D(:,:,jj) = Sigma_D(:,:,jj) + ...
            eye(size(Sigma_D(:,:,jj))) * nugsize(Sigma_D(:,:,jj)) ;
        
        % Now we can get the log factors of the likelihood for the new draw
        log_cond_dens_D_s(jj) = ...
            logmvnpdfFS(D(:,jj)',mu_D(:,jj)',Sigma_D_s(:,:,jj));
        log_obs_var_prior_s(jj) = ...
            log_obs_var_prior_fn(obs_var_s(jj));
        log_lik_obs_var_s = log_cond_dens_D_s(jj) + ...
            log_obs_var_prior_s(jj); 
        
        % And we get the likelihood for the old draw
        log_lik_obs_var = log_cond_dens_D(jj) + log_obs_var_prior(jj);

        % Now we can get the acceptance ratio
        log_alpha = log_lik_obs_var_s - log_lik_obs_var + ...
            obs_var_prop_log_mh_correction(...
                obs_var_s(jj),obs_var(jj));
        

        % Now accept theta1_s with probability min(alpha,1)
        if obs_var_same == 0 % If obs_var can differ for diffrnt objectives
            if log(rand) < log_alpha
                obs_var(jj) = obs_var_s(jj);
                obs_cov_mat(:,:,jj) = obs_cov_mat_s(:,:,jj);
                log_obs_var_prior(jj) = log_obs_var_prior_s(jj);
                log_cond_dens_D(jj) = log_cond_dens_D_s(jj); 
                accepted_obs_var(jj) = accepted_obs_var(jj) + 1;
            end
        end
    
    
    end
    end
    if obs_var_same == 1 % If obs_var constrained to be id. for all objctvs
        log_lik_obs_var_s = sum(log_cond_dens_D_s) + log_obs_var_prior_s(1);
        log_lik_obs_var = sum(log_cond_dens_D) + log_obs_var_prior(1);
        log_alpha = log_lik_obs_var_s - log_lik_obs_var + ...
            obs_var_prop_log_mh_correction(...
                obs_var_s(1),obs_var(1));
        if log(rand) < log_alpha
            obs_var = obs_var_s;
            obs_cov_mat = obs_cov_mat_s;
            log_obs_var_prior = log_obs_var_prior_s;
            log_cond_dens_D = log_cond_dens_D_s; 
            accepted_obs_var = accepted_obs_var + 1;
        end
    end
    
    %% Draw new des_var
    if des_var_est %&& ii>(3*upd)
    for jj = 1 : dim_y % For each model output
        
        % Need a non-Inf draw here
        des_var_s(jj) = Inf;
        while des_var_s(jj) == Inf
            des_var_s(jj) = ...
                des_var_proposal(des_var(jj),des_var_Sigma(jj)) ;
        end
        
        % Get acceptance ratio alpha
        % To do this, we'll first find the updated log factors of the
        % likelihood using the new draw des_var_s, using the updated cov. 
        % of the GPs. Only part of the big covariance
        % matrix Sigma need to be updated - des_cov_mat.
        des_cov_mat_s(:,:,jj) = eye(size(des_x,1)) * des_var_s(jj) ;

        Sigma_D_s(:,:,jj) = [...
            Sigma_emulator_simsim(:,:,jj) ...
                Sigma_emulator_simobs(:,:,jj) ...
                Sigma_emulator_simdes(:,:,jj) ;
            Sigma_emulator_simobs(:,:,jj)' ...
                Sigma_emulator_obsobs(:,:,jj) + ...
                    Sigma_obs_dscr_obsobs(:,:,jj) + ...
                    obs_cov_mat(:,:,jj) + ...
                    additional_discrep_cov_mat(:,:,jj)...
                Sigma_emulator_obsdes(:,:,jj) + ...
                Sigma_obs_dscr_obsdes(:,:,jj);
            Sigma_emulator_simdes(:,:,jj)' ...
                Sigma_emulator_obsdes(:,:,jj)' + ...
                    Sigma_obs_dscr_obsdes(:,:,jj)' ...
                Sigma_emulator_desdes(:,:,jj) + ...
                    Sigma_obs_dscr_desdes(:,:,jj) + ...
                    Sigma_des_dscr_desdes(:,:,jj) + ...
                    des_cov_mat_s(:,:,jj)...
        ];
        % Add nugget for computational tractability
        Sigma_D_s(:,:,jj) = Sigma_D_s(:,:,jj) + ...
            eye(size(Sigma_D_s(:,:,jj))) * nugsize(Sigma_D_s(:,:,jj)) ;
        
        % We also need the current Sigma_D, for comparison.
        Sigma_D(:,:,jj) = [...
            Sigma_emulator_simsim(:,:,jj) ...
                Sigma_emulator_simobs(:,:,jj) ...
                Sigma_emulator_simdes(:,:,jj) ;
            Sigma_emulator_simobs(:,:,jj)' ...
                Sigma_emulator_obsobs(:,:,jj) + ...
                    Sigma_obs_dscr_obsobs(:,:,jj) + ...
                    obs_cov_mat(:,:,jj) + ...
                    additional_discrep_cov_mat(:,:,jj)...
                Sigma_emulator_obsdes(:,:,jj) + ...
                Sigma_obs_dscr_obsdes(:,:,jj);
            Sigma_emulator_simdes(:,:,jj)' ...
                Sigma_emulator_obsdes(:,:,jj)' + ...
                    Sigma_obs_dscr_obsdes(:,:,jj)' ...
                Sigma_emulator_desdes(:,:,jj) + ...
                    Sigma_obs_dscr_desdes(:,:,jj) + ...
                    Sigma_des_dscr_desdes(:,:,jj) + des_cov_mat(:,:,jj)...
        ];
        % Add nugget for computational tractability
        Sigma_D(:,:,jj) = Sigma_D(:,:,jj) + ...
            eye(size(Sigma_D(:,:,jj))) * nugsize(Sigma_D(:,:,jj)) ;
        
        % Now we can get the log factors of the likelihood for the new draw
        log_cond_dens_D_s(jj) = ...
            logmvnpdfFS(D(:,jj)',mu_D(:,jj)',Sigma_D_s(:,:,jj));
        log_des_var_prior_s(jj) = ...
            log_des_var_prior_fn(des_var_s(jj));
        log_lik_des_var_s = log_cond_dens_D_s(jj) + ...
            log_des_var_prior_s(jj); 
        
        % And we get the likelihood for the old draw
        log_lik_des_var = log_cond_dens_D(jj) + log_des_var_prior(jj);

        % Now we can get the acceptance ratio
        log_alpha = log_lik_des_var_s - log_lik_des_var + ...
            des_var_prop_log_mh_correction(...
                des_var_s(jj),des_var(jj));

        % Now accept theta1_s with probability min(alpha,1)
        if log(rand) < log_alpha
            des_var(jj) = des_var_s(jj);
            des_cov_mat(:,:,jj) = des_cov_mat_s(:,:,jj);
            log_des_var_prior(jj) = log_des_var_prior_s(jj);
            log_cond_dens_D(jj) = log_cond_dens_D_s(jj); 
            accepted_des_var(jj) = accepted_des_var(jj) + 1;
        end
        
    end
    end
    
    %% Record draws
    theta1_rec(ii,:)       = theta1;
    theta2_rec(ii,:)       = theta2;
    obs_rho_rec(ii,:,:)    = obs_rho;
    obs_lambda_rec(ii,:)   = obs_lambda;
    des_rho_rec(ii,:,:)    = des_rho;
    des_lambda_rec(ii,:)   = des_lambda;
    obs_var_rec(ii,:)      = obs_var;
    des_var_rec(ii,:)      = des_var;
    
    %% Adjust adaptive proposal covariances, add new observations
    % Also update covariance hyperparameters, if applicable.
    
    %%%% First we adjust the proposal covariances every upd draws.
    if mod(ii,upd) == 0 && ii <= burn_in
        
        if verbose
            fprintf(repmat('\b',1,msg)); % Prepare to output to console
        end
        
        % Adjust proposal covariance for theta1
        mult_mult = max(.5,min(2,accepted_theta1/100/opt_acc_rate));
        mult_theta1 = mult_mult * mult_theta1;
        if verbose
            fprintf('theta1 proposal variance set to %g of previous\n',...
                mult_mult);
        end
        accepted_theta1 = 0 ;
        Sigma_theta1 = mult_theta1 * cov(logit(theta1_rec(1:ii,:)));
%         Sigma_theta1 = mult_theta1 * diag(var(logit(theta1_rec(1:ii,:))));
        
        % Adjust proposal covariance for theta2
        if numel(theta2)>0
            mult_mult = max(.5,min(2,accepted_theta2/100/opt_acc_rate));
            mult_theta2 = mult_mult * mult_theta2;
            if verbose
                fprintf(...
                    'theta2 proposal variance set to %g of previous\n',...
                    mult_mult);
            end
            accepted_theta2 = 0 ;
            Sigma_theta2 = mult_theta2 * cov(logit(theta2_rec(1:ii,:)));
        end
        
        % Adjust proposal covariance for obs_rho (if discrepancy used)
        if obs_discrep
        for jj = 1 : dim_y % For each model output
            mult_mult = ...
                max(.5,min(2,accepted_obs_rho(jj)/100/opt_acc_rate));
            mult_obs_rho(jj) = mult_mult * mult_obs_rho(jj);
            if verbose
                fprintf(...
                    'obs_rho %g proposal var set to %g of previous\n',...
                    jj,mult_mult);
            end
            accepted_obs_rho(jj) = 0 ;
            obs_Sigma_rho(:,:,jj) = ...
                mult_obs_rho * cov(log(obs_rho_rec(1:ii,:,jj)));
        end
        end

        % Adjust proposal covariance for obs_lambda (if discrepancy used)
        if obs_discrep
        for jj = 1 : dim_y % For each model output
            mult_mult = ...
                max(.5,min(2,accepted_obs_lambda(jj)/100/opt_acc_rate));
            mult_obs_lambda(jj) = mult_mult * mult_obs_lambda(jj);
            if verbose
                fprintf(...
                    ['obs_lambda %g proposal var '...
                    'set to %g of previous\n'],...
                    jj,mult_mult);
            end
            accepted_obs_lambda(jj) = 0 ;
            obs_Sigma_lambda(jj) = ...
                mult_obs_lambda(jj) * cov(log(obs_lambda_rec(1:ii,jj)));
        end
        end
        
        % Adjust proposal covariance for des_rho (if discrepancy used)
        if des_discrep
        for jj = 1 : dim_y % For each model output
            mult_mult = ...
                max(.5,min(2,accepted_des_rho(jj)/100/opt_acc_rate));
            mult_des_rho(jj) = mult_mult * mult_des_rho(jj);
            if verbose
                fprintf(['des_rho %g proposal var '...
                    'set to %g of previous\n'],...
                    jj,mult_mult);
            end
            accepted_des_rho(jj) = 0 ;
            des_Sigma_rho(:,:,jj) = ...
                mult_des_rho(jj) * cov(log(des_rho_rec(1:ii,:,jj)));
        end
        end

        % Adjust proposal covariance for des_lambda (if discrepancy used)
        if des_discrep
        for jj = 1 : dim_y % For each model output
            mult_mult = ...
                max(.5,min(2,accepted_des_lambda(jj)/100/opt_acc_rate));
            mult_des_lambda(jj) = mult_mult * mult_des_lambda(jj);
            if verbose
                fprintf(...
                    ['des_lambda %g proposal var '...
                    'set to %g of previous\n'],...
                    jj,mult_mult);
            end
            accepted_des_lambda(jj) = 0 ;
            des_Sigma_lambda(jj) = ...
                mult_des_lambda(jj) * cov(log(des_lambda_rec(1:ii,jj)));
        end
        end
        
        % Adjust proposal covariance for obs_var (if it is being estimated)
        for jj = 1 : dim_y % For each model output
        if obs_var_est(jj)
            mult_mult = ...
                max(.5,min(2,accepted_obs_var(jj)/100/opt_acc_rate));
            mult_obs_var(jj) = mult_mult * mult_obs_var(jj);
            if verbose
                fprintf(...
                    ['obs_var %g proposal var '...
                    'set to %g of previous\n'],...
                    jj,mult_mult);
            end
            accepted_obs_var(jj) = 0 ;
            obs_var_Sigma(jj) = ...
                mult_obs_var(jj) * cov(log(obs_var_rec(1:ii,jj)));
        end
        end
        
        % Adjust proposal covariance for des_var (if it is being estimated)
        if des_var_est
        for jj = 1 : dim_y % For each model output
            mult_mult = ...
                max(.5,min(2,accepted_des_var(jj)/100/opt_acc_rate));
            mult_des_var(jj) = mult_mult * mult_des_var(jj);
            if verbose
                fprintf(...
                    ['des_var %g proposal var '...
                    'set to %g of previous\n'],...
                    jj,mult_mult);
            end
            accepted_des_var(jj) = 0 ;
            des_var_Sigma(jj) = ...
                mult_des_var(jj) * cov(log(des_var_rec(1:ii,jj)));
        end
        end
        
        if verbose
            fprintf('\n');
            msg = fprintf('Completed: %g/%g  ',ii,M);
        end
        
        %% Add new observations (if sequential DoE is used)
        % To do: Make this work for models with multiple outputs
        if size(obs_x,1) < obs_final_size
            
            % How many observations to draw
            new_obs_size = ...
                min(obs_per_upd,obs_final_size - size(obs_x,1));
            
            % Get theta2 draws to use for new observations
            t2_idx = randsample(upd,new_obs_size);
            t2_new = theta2_rec((t2_idx + ii-upd),:);
            x_new = ...
                x_new_all(x_location_idx:x_location_idx+new_obs_size-1,:);
            x_location_idx = x_location_idx + new_obs_size;
            
            % Get new observations
            obs_new_noiseless = true_phenomenon(x_new,t2_new);
            
            % Add observation error
            obs_new = obs_new_noiseless + randn(size(x_new,1),1) * ...
                true_obs_var ;
            
            % Update set of observations
            obs_x = [obs_x ; x_new ] ;
            obs_t2 = [obs_t2 ; t2_new ] ;
            obs_y = [obs_y ; obs_new ] ;
            
            % Update all vectors and matrices that depend on observations
            % D is the vector of all outputs from all sources.
            D = [ sim_y ; obs_y ; des_y ] ;
            % R is the vector of the simulator outputs and real obss.
            R = [ sim_y ; obs_y ] ;
            % Now the covariance matrices that depend on obs
            obs_cov_mat = eye(size(obs_x,1)) * obs_var;
            obs_cov_mat_s = eye(size(obs_x,1)) * obs_var;
            additional_discrep_cov_mat = ...
                additional_discrep_cov(obs_x,theta1) ; % Default 0
            additional_discrep_cov_mat_s = additional_discrep_cov_mat ; 
            Sigma_emulator_simobs = ...
                gp_cov(emulator_rho,[sim_x sim_t1 sim_t2],...
                    [obs_x repmat(theta1',size(obs_x,1),1) obs_t2],...
                    emulator_lambda,false);
            Sigma_emulator_obsobs = ...
                gp_cov(emulator_rho,...
                    [obs_x repmat(theta1',size(obs_x,1),1) obs_t2],...
                    [obs_x repmat(theta1',size(obs_x,1),1) obs_t2],...
                    emulator_lambda,false);
            Sigma_emulator_obsdes = ...
                gp_cov(emulator_rho,...
                    [obs_x repmat(theta1',size(obs_x,1),1) obs_t2],...
                    [des_x repmat(theta1',size(des_x,1),1) ...
                        repmat(theta2',size(des_x,1),1)],...
                    emulator_lambda,false);
            Sigma_obs_dscr_obsobs = ...
                gp_cov(obs_rho,[obs_x obs_t2],[obs_x obs_t2],...
                    obs_lambda,false);
            Sigma_obs_dscr_obsdes = ...
                gp_cov(obs_rho,[obs_x obs_t2],...
                    [des_x repmat(theta2',size(des_x,1))],...
                    obs_lambda,false);
%             Sigma_obs_dscr_desdes = ...
%                 gp_cov(obs_rho,[des_x repmat(theta2',size(des_x,1))],...
%                     [des_x repmat(theta2',size(des_x,1))],...
%                     obs_lambda,false);
            % Now to combine everything into two big covariance matrices:
            Sigma_R = [... % The covariance of R
                Sigma_emulator_simsim Sigma_emulator_simobs ; 
                Sigma_emulator_simobs' ...
                    Sigma_emulator_obsobs + ...
                    Sigma_obs_dscr_obsobs + obs_cov_mat + ...
                    additional_discrep_cov(obs_x,theta1)...%Default adc()=0
                ];
            Sigma_D = [... % The covariance of D
                Sigma_R ...
                    [Sigma_emulator_simdes; ...
                        Sigma_emulator_obsdes + Sigma_obs_dscr_obsdes];
                Sigma_emulator_simdes' ...
                    Sigma_emulator_obsdes' + Sigma_obs_dscr_obsdes' ...
                    Sigma_emulator_desdes + Sigma_obs_dscr_desdes + ...
                        Sigma_des_dscr_desdes + des_cov_mat];
            % Add nugget for computational tractability:
            Sigma_R = Sigma_R + eye(size(Sigma_R)) * nugsize(Sigma_R) ;
            Sigma_D = Sigma_D + eye(size(Sigma_D)) * nugsize(Sigma_D) ;
            % Simulator, observation and target means
            mu_R = [mean_sim([sim_x,sim_t1,sim_t2]) ; ...
                mean_sim([obs_x,repmat(theta1',size(obs_x,1),1),obs_t2])+ ...
                    mean_obs(obs_x,obs_t2) + ...
                    additional_discrep_mean(theta1)]; %Default adm() is 0
            mu_D = [mu_R ; 
                mean_sim([des_x,repmat(theta1',size(des_x,1),1),...
                    repmat(theta2',size(des_x,1),1)]) + ...
                    mean_obs(des_x,repmat(theta2',size(des_x,1),1)) + ...
                    mean_des(des_x)]; % Mean of D
            % Clear the proposed versions of the above values, since they
            % may have the wrong size now
            clear Sigma_D_s Sigma_R_s mu_D_s mu_R_s ...
                Sigma_emulator_simobs_s Sigma_emulator_obsdes_s ...
                Sigma_emulator_obsobs_s Sigma_obs_dscr_obsobs_s ...
                Sigma_obs_dscr_obsdes_s
            % Now to get the log likelihoods
            log_cond_dens_D = logmvnpdfFS(D',mu_D',Sigma_D);
            
            % Output to console 
            if verbose
                fprintf(repmat('\b',1,msg)); % Prepare to output to console
                fprintf('New observations gathered\n');
                disp(x_new); disp(t2_new); disp(obs_new);
                fprintf('\n');
                msg = fprintf('Completed: %g/%g  \n',ii,M);
            end
        end % end of addition of new observations for sequential DoE
        
        %%%% Now we find the MLEs of covariance hyperparameters if desired
        % To do: Make this work for models with multiple outputs
        % Get MLEs for the observation discrepancy
        if obs_discrep_use_MLEs
            
            % Get point estimate of theta1
%             t1_hat = mean(theta1_rec((ii-upd+1):ii,:)) ;
            t1_hat = mean(theta1_rec(1:ii,:),1) ;
            
            % Get observed discrepancy
            % If emulator is used, get emulator value at observed locations
            if emulator_use
                error('Error: Cov. MLEs not yet implemented for emulator');
            else
                mod_y = mean_sim([obs_x,repmat(t1_hat,size(obs_x,1),1),...
                    obs_t2]) ;
            end
            
            observed_discrep = obs_y - mod_y ;
            
            % Get updated mean 
%             X = [ones(size(obs_x,1),1) obs_x obs_t2];
%             B = X\observed_discrep;
%             mean_obs = @(x,t) [ones(size(x,1),1) x t]*B;
            obs_fn = @(rl) -logmvnpdfFS(observed_discrep',...
                mean_obs(obs_x,obs_t2)',...
                gp_cov(rl(1:(end-1)),[obs_x obs_t2],[obs_x obs_t2],...
                rl(end),false) + eye(size(obs_x,1))*nugsize(1));
            % Perform minimization
            A = [] ; b = [] ; Aeq = [] ; beq = [] ; 
            lb = 0*ones(1, 1 + size([obs_x obs_t2],2)) ; 
            ub = [ ones(1, size([obs_x obs_t2],2)) Inf ];
            x0 = [obs_rho(:); obs_lambda]'; 
            rl = fmincon(obs_fn,x0,A,b,Aeq,beq,lb,ub);
            obs_rho = rl(1:(end-1)) ; obs_lambda = rl(end) ; 
            
            % Update relevant covariance matrices
            Sigma_obs_dscr_obsobs = ...
                gp_cov(obs_rho,[obs_x obs_t2],[obs_x obs_t2],...
                    obs_lambda,false);
            Sigma_obs_dscr_obsdes = ...
                gp_cov(obs_rho,[obs_x obs_t2],...
                    [des_x repmat(theta2',size(des_x,1))],...
                    obs_lambda,false);
            Sigma_obs_dscr_desdes = ...
                gp_cov(obs_rho,[des_x repmat(theta2',size(des_x,1))],...
                    [des_x repmat(theta2',size(des_x,1))],...
                    obs_lambda,false);
                
            % Update likelihoods for current draws
            Sigma_R = [... % The covariance of R
                Sigma_emulator_simsim Sigma_emulator_simobs ; 
                Sigma_emulator_simobs' ...
                    Sigma_emulator_obsobs + ...
                    Sigma_obs_dscr_obsobs + obs_cov_mat + ...
                    additional_discrep_cov(obs_x,theta1)...%Default adc()=0
                ];
            Sigma_D = [... % The covariance of D
                Sigma_R ...
                    [Sigma_emulator_simdes; ...
                        Sigma_emulator_obsdes + Sigma_obs_dscr_obsdes];
                Sigma_emulator_simdes' ...
                    Sigma_emulator_obsdes' + Sigma_obs_dscr_obsdes' ...
                    Sigma_emulator_desdes + Sigma_obs_dscr_desdes + ...
                        Sigma_des_dscr_desdes + des_cov_mat];
            % Add nugget for computational tractability:
            Sigma_D = Sigma_D + eye(size(Sigma_D)) * nugsize(Sigma_D) ;

            % Now to get the log likelihoods
            mu_R = [mean_sim([sim_x,sim_t1,sim_t2]) ; ...
                mean_sim([obs_x,repmat(theta1',size(obs_x,1),1),obs_t2])+ ...
                    mean_obs(obs_x,obs_t2) + ...
                    additional_discrep_mean(theta1)]; %By default adm()=0
            mu_D = [mu_R ; 
                mean_sim([des_x,repmat(theta1',size(des_x,1),1),...
                    repmat(theta2',size(des_x,1),1)]) + ...
                    mean_obs(des_x,repmat(theta2',size(des_x,1),1)) + ...
                    mean_des(des_x)]; % Mean of D
            log_cond_dens_D = logmvnpdfFS(D',mu_D',Sigma_D);
            
        end
        
    end
    
    %% Update plots
    if mod(ii,upd) == 0 && doplot % Update plots every upd loops of MCMC
        
%         figure(fig); % Make the appropriate figure current
        
        % After the burn_in is over, we exclude it from the plots
        if ii> burn_in, startplot=burn_in; end 
        
        % Plot
        ax_idx = 1 ; % This will index the current axes
        % Plot theta1
        for jj = 1 : numel(theta1)
            subplot(ax(ax_idx));
            plot(theta1_rec(startplot:ii,jj),'ko');
            ax_idx = ax_idx + 1 ;
            title(sprintf('\\theta_1_,_%g',jj));
        end
        
        % Plot theta2
        for jj = 1 : numel(theta2)
            subplot(ax(ax_idx));
            plot(theta2_rec(startplot:ii,jj),'ko');
            ax_idx = ax_idx + 1 ;
            title(sprintf('\\theta_2_,_%g',jj));
        end
        
        % Plot obs_rho
        for jj = 1 : (dim_y * obs_discrep)
            for kk = 1 : numel(obs_rho(jj))
                subplot(ax(ax_idx));
                plot(obs_rho_rec(startplot:ii,kk,jj),'ko');
                ax_idx = ax_idx + 1 ;
                title(sprintf('\\rho_o_b_s_,_%g_,_%g',jj,kk));
            end
        end
        
        % Plot obs_lambda
        for jj = 1 : (dim_y * obs_discrep)
            subplot(ax(ax_idx));
            plot(obs_lambda_rec(startplot:ii,jj),'ko');
            ax_idx = ax_idx + 1 ;
            title(sprintf('\\lambda_o_b_s_,_%g',jj));
        end
        
        % Plot des_rho
        for jj = 1 : (dim_y * des_discrep)
            for kk = 1 : numel(des_rho(:,jj))
                subplot(ax(ax_idx));
                plot(des_rho_rec(startplot:ii,kk,jj),'ko');
                ax_idx = ax_idx + 1 ;
                title(sprintf('\\rho_d_e_s_,_%g_,_%g',jj,kk));
            end
        end
        
        % Plot des_lambda
        for jj = 1 : (dim_y * des_discrep)
            subplot(ax(ax_idx));
            plot(des_lambda_rec(startplot:ii,jj),'ko');
            ax_idx = ax_idx + 1 ;
            title(sprintf('\\lambda_d_e_s_,_%g',jj));
        end
        
        % Plot obs_var
        for jj = 1 : sum(obs_var_est)
            subplot(ax(ax_idx));
            plot(obs_var_rec(startplot:ii,jj),'ko');
            ax_idx = ax_idx + 1 ;
            title(sprintf('\\sigma^2_o_b_s_,_%g',jj));
        end
        
        % Plot des_var
        for jj = 1 : (dim_y * des_var_est)
            subplot(ax(ax_idx));
            plot(des_var_rec(startplot:ii,jj),'ko');
            ax_idx = ax_idx + 1 ;
            title(sprintf('\\sigma^2_d_e_s_,_%g',jj));
        end
        
%         % If values sampled are multivariate, then cycle through cols for
%         % display:
%         col_theta1     = 1 + mod(col_theta1,size(theta1_rec,2));
%         col_theta2     = 1 + mod(col_theta2,size(theta2_rec,2));
%         col_obs_rho    = 1 + mod(col_obs_rho,size(obs_rho_rec,2));
%         col_obs_lambda = 1 + mod(col_obs_lambda,size(obs_lambda_rec,2));
%         col_des_rho    = 1 + mod(col_des_rho,size(des_rho_rec,2));
%         col_des_lambda = 1 + mod(col_des_lambda,size(des_lambda_rec,2));
%         
%         % Plot
%         subplot(ax(1));
%         plot(theta1_rec(startplot:ii,col_theta1),'ko');
%         subplot(ax(2));
%         if numel(theta2_rec)>0
%             plot(theta2_rec(startplot:ii,col_theta2),'ko');
%         end
%         subplot(ax(3));
%         hold off;
%         for jj=1:size(obs_rho(:),1)
%             plot(obs_rho_rec(startplot:ii,jj),'o'); hold on;
%         end
% %         plot(obs_rho_rec(startplot:ii,col_obs_rho),'ko');
%         subplot(ax(4));
%         plot(obs_lambda_rec(startplot:ii,col_obs_lambda),'ko');
%         % Only need plot these two if des_discrep == true
%         if des_discrep
%             subplot(ax(5));
%             plot(des_rho_rec(startplot:ii,col_des_rho),'ko');
%             subplot(ax(6));
%             plot(des_lambda_rec(startplot:ii,col_des_lambda),'ko');
%         end
        
        drawnow;
    end
    
    %% Prepare for next loop
    if mod(ii,50)==0
        fprintf(repmat('\b',1,msg));
        msg = fprintf('Completed: %g/%g  ',ii,M);
    end
    
end

%% Pack up and leave
fprintf('\n');
theta1_os = theta1_rec .* range_t1 + min_t1;
if numel(theta2_rec)>0, theta2_os = theta2_rec .* range_t2 + min_t2;
else, theta2_os = theta2_rec ; end
settings.obs_x = obs_x ;
settings.obs_t2 = obs_t2 ;
settings.obs_y = obs_y ;
results = struct('theta1',theta1_os,...
    'theta2',theta2_os,...
    'obs_rho',obs_rho_rec,...
    'obs_lambda',obs_lambda_rec,...
    'des_rho',des_rho_rec,...
    'des_lambda',des_lambda_rec,...
    'obs_var',obs_var_rec,...
    'des_var',des_var_rec,...
    'settings',settings);

end
